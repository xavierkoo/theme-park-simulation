globals [   

]  

breed [visitors visitor]

visitors-own [
  archetype
  patience-level ; baulking point, max queue time of visitor, influenced by attraction(pops) and archetype.
  satisfaction-level ; threshold for determining whether visitor stays in the park influenced by archetype and expected-attractions-rate
  expected-attractions-rate ; number of attractions visitors expects to take part in by the end of the day influenced by archetype
  staying-time ; duration of visitors staying in the park.
  repeat-ride? ; boolean, whether visitor repeats the ride
  visited-attractions ; list of visited attractions
  priority-pass-usage-limit ; value 1-99(unlimited) max number of pass a visitor can get in a visit
  current-queue ; gpt ??
  attraction-pref ; 0.0-1.0 indicates visitors pref for rides of activities (larger number pref for rides)
  decision-made? ; boolean, true if the visitor has made a decision on where to go next
  going-home?; boolean, true if visitor is going home
  
  current-location ; (Attraction Agent)
  current-location-name; (Attraction Name)
  next-destination ; (Attraction Agent) where the visitor is currently headed to
  isWaiting ; boolean indicating if the turtle is waiting in a queue
  waitTime ; how long the turtle has been waiting
  path
  moving;
  next-dest-name 

]

to visitor-make-decisions
  ask visitors [
    if ticks > closing-time [
      set next-destination one-of turtles with [label = "\nEntrance"]
      visitor-create-path
      set decision-made? true
      set going-home? true
      stop
    ]

    if not decision-made? [
      ; Get current location of the visitor
      let current-xcor xcor
      let current-ycor ycor
      
      ; Define locally activities/rides and their positions
      let local-activities ["Laser" "Enchanted" "Hunt" "Wizard" "Observatory" "Maze" "Robotics" "Carnival"]
      let activities-positions [[-12 -8] [28 20] [-28 20] [28 -8] [-20 5] [20 25] [-28 -8] [0 15]]
      
      let local-rides ["Thunderbolt" "Carousel" "Aqua" "Skyward" "Flight" "Coaster" "Glide" "Dash" "Voyage" "Tunnel" "Falls" "Safari"]
      let rides-positions [[-20 -8 true] [-20 20 true] [20 -8 true] [20 20 true] [-20 25 false] [11 -8 false]
      [0 20 false] [0 25 false] [-13 5 false] [20 5 false] [28 5 false] [20 -15 false]]
      
      ; Check if the visitor's satisfaction level is below the threshold
      if satisfaction-level < 50 [
;        print("Going Home, Not Satisfied")
        set next-destination one-of turtles with [label = "\nEntrance"]
        visitor-create-path
        set decision-made? true
        set going-home? true
        stop
      ]

      ; Determine if the visitor prefers rides or activities and calculate distances
      ifelse random-float 1 < attraction-pref
      ; ride chosen
      [
        ; Calculate cumulative probabilities
        let ride-distances map [p -> distancexy first p last butlast p] rides-positions
        let popularity-adjustment map [p -> ifelse-value last p [1.5] [1]] rides-positions ; popular rides have 1.5 times multiplier
        let adjusted-ride-distances map [pair -> (first pair) * (last pair)] (map list ride-distances popularity-adjustment)
        let ride-probabilities n-values (length adjusted-ride-distances) [i -> 1 - (item i adjusted-ride-distances) / (max adjusted-ride-distances)]
        let cumulative-ride-probabilities fput 0 (reduce sentence (map list ride-probabilities))
        
        ; Generate a random threshold to choose a ride based on weighted probabilities
        let threshold random-float last cumulative-ride-probabilities
        let chosen-ride-index -1 ; Initialize to an invalid index
        
        ; Find the index where the threshold is less than the cumulative probability
        foreach n-values (length cumulative-ride-probabilities) [i -> i] [
          i ->
          if threshold < item i cumulative-ride-probabilities and chosen-ride-index = -1 [
            set chosen-ride-index i
          ]
        ]
        
        ; Adjust for the offset introduced by adding a 0 at the start of cumulative-ride-probabilities
        if chosen-ride-index > 0 [
          set chosen-ride-index chosen-ride-index - 1
        ]
        
        ; Proceed based on whether a valid ride is chosen
        ifelse chosen-ride-index != -1 [
          let chosen-ride item chosen-ride-index local-rides
          let chosen-ride-position item chosen-ride-index rides-positions
          ifelse repeat-ride? and member? chosen-ride visited-attractions [
            ; Logic to handle repeating a ride
            set next-destination one-of attractions with [attraction-name = chosen-ride]
            visitor-create-path
          ] [
            ; If not repeating or haven't visited this ride before, proceed normally
            if not member? chosen-ride visited-attractions [
              set visited-attractions lput chosen-ride visited-attractions
              set next-destination one-of attractions with [attraction-name = chosen-ride]
              visitor-create-path
            ]
          ]
      
        ] [
          ; If no activity is chosen, set destination to the entrance
          set next-destination one-of turtles with [label = "\nEntrance"]
          visitor-create-path
        ]
      ]
      ; activity chosen
      [
        ; Calculate cumulative probabilities
        let activity-distances map [p -> distancexy first p last p] activities-positions
        let activity-probabilities n-values (length activity-distances) [i -> 1 - (item i activity-distances) / (max activity-distances)]
        let cumulative-activity-probabilities (reduce sentence (map list (fput 0 activity-probabilities)))
        
        ; Choose an activity based on the weighted probabilities
        let chosen-activity-index position true (map [p -> random-float 1 < p] cumulative-activity-probabilities)
        ifelse chosen-activity-index != FALSE and chosen-activity-index >= 0 and chosen-activity-index < length local-activities [
          let chosen-activity item chosen-activity-index local-activities
          let chosen-activity-position item chosen-activity-index activities-positions
          ifelse repeat-ride? and member? chosen-activity visited-attractions [
            ; Logic to handle repeating a ride
            set next-destination one-of attractions with [attraction-name = chosen-activity]
            visitor-create-path
          ] [
            ; If not repeating or haven't visited this ride before, proceed normally
            if not member? chosen-activity visited-attractions [
              set visited-attractions lput chosen-activity visited-attractions
              set next-destination one-of attractions with [attraction-name = chosen-activity]
              visitor-create-path
            ]
          ]

        ] [
          ; If no activity is chosen, set destination to the entrance
          set next-destination one-of turtles with [label = "\nEntrance"]
          visitor-create-path
        ]
      ]
      ; At the end of the decision-making process, set the flag to true
      set decision-made? true
    ]
  ]
end


; Move towards the selected attraction
to visitor-move-to-attraction
  ; Check if the visitor has a destination
    ask visitors [
    ifelse isWaiting [
      ; If the visitor is waiting, no need to move
      ; The update-queues procedure will handle their progression

    ] [
      ; The visitor is not waiting and should move towards the next destination.
      if not empty? path [
        if not moving [
          set next-dest-name first path 
          let nd next-dest-name
          
          set current-location one-of attractions with [attraction-name = nd]
          if current-location = nobody [
            set current-location one-of entrances with [name = nd]
            if current-location = nobody [
              print (word "next-dest-name " next-dest-name " not found.")
            ]
          ]
          set moving true
        ]

        if current-location != nobody and moving [
          face current-location
          fd 1 ; Adjust speed if necessary. Consider using a variable for flexibility.
          if distance current-location < 1 [
            ; Check the queue and decide whether to join, decision-made? set back to false if queue is longer than visitor patience level
            ; The visitor has arrived at the destination.
            set current-location-name next-dest-name
            set path but-first path 
          
            if length path = 0 and [breed] of current-location = entrances[  
              if ticks < closing-time [ 
                set decision-made? false
              ]
            ]
            if [breed] of current-location = entrances and going-home? [
                die
            ]
            if length path = 0 and [breed] of current-location = attractions [
              visitor-check-queue
            ]   

          set moving false
          ]
        ]
      ]
    ]
  ]
end

to visitor-create-path 
  let currentname ""
  ifelse [breed] of current-location = attractions [
    ; Handle the case for attractions
    set currentname [attraction-name] of current-location  ; Use 'attraction-name' for attractions
  ] [
    ; Handle the case for entrances or any other breed
    if [breed] of current-location = entrances [
      set currentname [name] of current-location  ; Use 'name' for entrances
    ]
  ]
  let next-destination-name ""
  ifelse [breed] of next-destination = attractions [
    ; Handle the case for attractions
    set next-destination-name [attraction-name] of next-destination  ; Use 'attraction-name' for attractions
  ] [
    ; Handle the case for entrances or any other breed
    if [breed] of next-destination = entrances [
      set next-destination-name [name] of next-destination  ; Use 'name' for entrances
    ]
  ]
  set path find-path-bfs currentname next-destination-name
  
end

; Check the queue of the attraction and decide whether to stay 
to visitor-check-queue
  ; Check if the visitor is currently deciding to join a queue
  
  ; Assess the current destination's queue length
  let queue-length length [queue] of current-location
  
  ; Compare queue length with visitor's patience level
  ifelse queue-length > patience-level [
    ; If queue is longer than patience level, decide not to join and make a new decision
    set decision-made? false
  ] [
    ; If queue is within patience level, join the queue
    
    ask current-location [
      
      set queue lput myself queue
      set waiting-count length queue
      
    ]
    set isWaiting true
  ]
 
end

; Update satisfaction based on experiences
to visitor-update-satisfaction
  ask visitors [
    ; Calculate the expected number of attractions by this time
    let expected-attractions-so-far (expected-attractions-rate / closing-time) * ticks
    ; Check if the visitor has met, exceeded, or not met this expected number
    ifelse length visited-attractions < expected-attractions-so-far [
;      print("Decrease satisfaction")
      ; Decrease satisfaction if fewer attractions visited than expected
      set satisfaction-level satisfaction-level - satisfaction-modifier  ; Adjust the decrease
      ; Ensure satisfaction level does not go below 0
      if satisfaction-level < 0 [
        set satisfaction-level 0
      ]
    ] [
      if length visited-attractions > expected-attractions-so-far [
;        print("Increase satisfaction")
        ; Increase satisfaction if more attractions visited than expected
        set satisfaction-level satisfaction-level + satisfaction-modifier  ; Adjust the increase
        ; Ensure satisfaction level does not exceed 100
        if satisfaction-level > 100 [
          set satisfaction-level 100
        ]
      ]
      ; No change if the visitor has met the expected number exactly
    ]
  ]
end




