globals [   

]  

breed [visitors visitor]

visitors-own [
  archetype
  patience-level ; baulking point, max queue time of visitor, influenced by attraction(pops) and archetype.
  satisfaction-level ; threshold for determining whether visitor stays in the park influenced by archetype and expected-attractions-rate
  expected-attractions-rate ; number of attractions visitors expects to take part in by the end of the day influenced by archetype
  staying-time ; duration of visitors staying in the park.
  repeat-ride? ; boolean, whether visitor repeats the ride
  priority-pass-usage-limit ; value 1-99(unlimited) max number of pass a visitor can get in a visit
  current-queue ; gpt ??
  attraction-pref ; 0.0-1.0 indicates visitors pref for rides of activities (larger number pref for rides)
  destination ; where the visitor is currently headed to
  decision-made? ; boolean, true if the visitor has made a decision on where to go next
]

to visitor-make-decisions
  ask visitors [
    if not decision-made? [
      ; Get current location of the visitor
      let current-xcor xcor
      let current-ycor ycor
      
      ; Define locally activities/rides and their positions
      let local-activities ["Laser" "Enchanted" "Hunt" "Wizard" "Observatory" "Maze" "Robotics" "Carnival"]
      let activities-positions [[-20 -8] [28 20] [-28 20] [28 -3] [-20 10] [20 25] [-28 -3] [0 15]]
      
      let local-rides ["Thunderbolt" "Carousel" "Aqua" "Skyward" "Flight" "Coaster" "Glide" "Dash" "Voyage" "Tunnel" "Falls" "Safari"]
      let rides-positions [[-20 -3 true] [-20 20 true] [20 -3 true] [20 20 true] [-20 25 true] [11 -3 false]
      [0 20 false] [0 25 false] [-28 10 false] [20 10 false] [28 10 false] [20 -8 false]]
      
      ; Determine if the visitor prefers rides or activities and calculate distances
      ifelse random-float 1 < attraction-pref
      ; ride chosen
      [
        ; Calculate cumulative probabilities
        let ride-distances map [p -> distancexy first p last butlast p] rides-positions
        let popularity-adjustment map [p -> ifelse-value last p [1.5] [1]] rides-positions ; popular rides have 1.5 times multiplier
        let adjusted-ride-distances map [pair -> (first pair) * (last pair)] (map list ride-distances popularity-adjustment)
        let ride-probabilities n-values (length adjusted-ride-distances) [i -> 1 - (item i adjusted-ride-distances) / (max adjusted-ride-distances)]
        let cumulative-ride-probabilities fput 0 (reduce sentence (map list ride-probabilities))
        
        ; Generate a random threshold to choose a ride based on weighted probabilities
        let threshold random-float last cumulative-ride-probabilities
        let chosen-ride-index -1 ; Initialize to an invalid index
        
        ; Find the index where the threshold is less than the cumulative probability
        foreach n-values (length cumulative-ride-probabilities) [i -> i] [
          i ->
          if threshold < item i cumulative-ride-probabilities and chosen-ride-index = -1 [
            set chosen-ride-index i
          ]
        ]
        
        ; Adjust for the offset introduced by adding a 0 at the start of cumulative-ride-probabilities
        if chosen-ride-index > 0 [
          set chosen-ride-index chosen-ride-index - 1
        ]
        
        ; Proceed based on whether a valid ride is chosen
        ifelse chosen-ride-index != -1 [
          let chosen-ride item chosen-ride-index local-rides
          let chosen-ride-position item chosen-ride-index rides-positions
          set destination one-of attractions with [attraction-name = chosen-ride]
        ] [
          ; Handle case when no ride is chosen
          set destination nobody
        ]
      ]
      ; activity chosen
      [
        ; Calculate cumulative probabilities
        let activity-distances map [p -> distancexy first p last p] activities-positions
        let activity-probabilities n-values (length activity-distances) [i -> 1 - (item i activity-distances) / (max activity-distances)]
        let cumulative-activity-probabilities (reduce sentence (map list (fput 0 activity-probabilities)))
        
        ; Choose an activity based on the weighted probabilities
        let chosen-activity-index position true (map [p -> random-float 1 < p] cumulative-activity-probabilities)
        ifelse chosen-activity-index != FALSE and chosen-activity-index >= 0 and chosen-activity-index < length local-activities [
          let chosen-activity item chosen-activity-index local-activities
          let chosen-activity-position item chosen-activity-index activities-positions
          set destination one-of attractions with [attraction-name = chosen-activity]
        ] [
          ; Handle case when no activity is chosen
          set destination nobody
        ]
      ]
      ; At the end of the decision-making process, set the flag to true
      set decision-made? true
    ]
    visitor-move-to-attraction
  ]
end


; Move towards the selected attraction
to visitor-move-to-attraction
  ; Check if the visitor has a destination
  if destination != nobody [
    ; Face the destination
    face destination
    ; Move towards the destination
    fd 1 ; Move forward by 1 step, adjust the step size as necessary
    ; Check if the visitor has arrived
    if distance destination <= 1 [ ; assuming a threshold of 1 unit for arrival
      ; Arrived at the destination
      set decision-made? false
    ]
  ]
end


; Check the queue of the attraction and decide whether to stay 
to visitor-check-queue 
  ; Implement logic based on patience level and queue length 
end  

; Visitor enjoys the attraction and updates state 
to visitor-enjoy-attraction 
  ; Implement logic for enjoying an attraction and its effects 
end  

; Update satisfaction based on experiences 
to visitor-update-satisfaction 
  ; Implement logic for updating satisfaction levels 
end  

; Check if visitor decides to leave the park 
to visitor-check-leaving-conditions 
  ; Implement logic based on satisfaction level and staying time 
end 